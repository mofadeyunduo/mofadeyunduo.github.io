## Goroutine 模型
 
参考 [GMP](https://learnku.com/articles/41728)。

## 为什么使用协程

主要是和线程对比。

### 协程更轻量

假设我们有 1000 个网络请求，线程 1000 个需要 `1000 MB`，协程只需要 `4000 KB = 4M` 左右。

### 上下文切换更快

线程切换是 `操作系统` 操作的，线程调度是要从用户态转变为内核态，内核保存大量的 CPU 上下文信息。

协程切换是 `程序` 操作的，不需要转变成内核态，自行保存少量的上下文的信息。

此外，代码还可以控制上下文切换的操作，如 Goroutine，当发生 `系统调用` 的时候，可以解除 P 和 M1 之间的关系，让 M1 等待系统调用结果，换另外一个线程 M2 处理其他协程的任务。 

具体可参考[为什么协程切换的代价比线程切换低?](https://www.zhihu.com/question/308641794)

## 协程不解决高并发 IO 的问题

经常看到这样的标题，协程是高并发 IO 的利器，可实际文章也没说什么和 IO 相关的。

这种文章是错误的。协程和`高并发`有关，因为线程复用可以显著的降低线程上下文切换的时间，但和 `IO` 无关，IO 只会磁盘速度、采用了什么 IO 技术。

具体可以参考[理解协程，以及协程如何提升IO阻塞时的性能](https://blog.csdn.net/u010841296/article/details/89608492)。